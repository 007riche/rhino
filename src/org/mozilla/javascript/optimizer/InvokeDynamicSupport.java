/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

package org.mozilla.javascript.optimizer;

import jdk.dynalink.CallSiteDescriptor;
import jdk.dynalink.StandardOperation;
import jdk.dynalink.support.ChainedCallSite;
import org.mozilla.javascript.Callable;
import org.mozilla.javascript.Context;
import org.mozilla.javascript.ScriptRuntime;
import org.mozilla.javascript.Scriptable;
import org.mozilla.javascript.ScriptableObject;
import org.mozilla.javascript.ScriptableObjectSlot;

import java.lang.invoke.CallSite;
import java.lang.invoke.ConstantCallSite;
import java.lang.invoke.MethodHandle;
import java.lang.invoke.MethodHandles;
import java.lang.invoke.MethodHandles.Lookup;
import java.lang.invoke.MethodType;
import java.lang.invoke.MutableCallSite;

/**
 * This class contains methods that are called by generated bytecode that
 * sets up and uses the InvokeDynamic instruction.
 */

public class InvokeDynamicSupport {

    static final boolean DYNALINK = true;

    static class CachingCallSite extends MutableCallSite {
        final Lookup lookup;

        CachingCallSite(Lookup lookup, MethodType type) {
            super(type);
            this.lookup = lookup;
        }
    }

    @SuppressWarnings("unused")
    public static CallSite bootstrapProp0Call(MethodHandles.Lookup lookup,
                                              String name, MethodType type) {
        if (DYNALINK) {
            return Linker.getLinker().link(
                    new ChainedCallSite(
                            new CallSiteDescriptor(lookup, StandardOperation.CALL,
                                    MethodType.methodType(Object.class,
                                            Object.class, String.class, Context.class,
                                            Scriptable.class))));
        }
        return new ConstantCallSite(CALLPROP0_FALLBACK);
    }

    @SuppressWarnings("unused")
    public static CallSite bootstrapProp1Call(MethodHandles.Lookup lookup,
                                              String name, MethodType type) {
        if (DYNALINK) {
            return Linker.getLinker().link(
                    new ChainedCallSite(
                            new CallSiteDescriptor(lookup, Linker.CALL1,
                                    MethodType.methodType(Object.class,
                                            Object.class, String.class, Object.class, Context.class,
                                            Scriptable.class))));
        }
        return new ConstantCallSite(CALLPROP1_FALLBACK);
    }

    @SuppressWarnings("unused")
    public static CallSite bootstrapProp2Call(MethodHandles.Lookup lookup,
                                              String name, MethodType type) {
        if (DYNALINK) {
            return Linker.getLinker().link(
                    new ChainedCallSite(
                            new CallSiteDescriptor(lookup, Linker.CALL2,
                                    MethodType.methodType(Object.class,
                                            Object.class, String.class, Object.class, Object.class,
                                            Context.class, Scriptable.class))));
        }
        return new ConstantCallSite(CALLPROP2_FALLBACK);
    }

    @SuppressWarnings("unused")
    public static CallSite bootstrapPropNCall(MethodHandles.Lookup lookup,
                                              String name, MethodType type) {
        if (DYNALINK) {
            return Linker.getLinker().link(
                    new ChainedCallSite(
                            new CallSiteDescriptor(lookup, Linker.CALLN,
                                    MethodType.methodType(Object.class,
                                            Object.class, String.class, Object[].class,
                                            Context.class, Scriptable.class))));
        }
        return new ConstantCallSite(CALLPROPN_FALLBACK);
    }

    /**
     * Begin the process of setting up a CallSite to get the property of an object.
     */
    @SuppressWarnings("unused")
    public static CallSite bootstrapGetObjectProp(MethodHandles.Lookup lookup,
                                                  String name, MethodType type) {
        if (DYNALINK) {
            return Linker.getLinker().link(
                    new ChainedCallSite(
                            new CallSiteDescriptor(lookup, StandardOperation.GET,
                                    MethodType.methodType(Object.class,
                                            Object.class, String.class, Context.class,
                                            Scriptable.class))));
        }
        return new ConstantCallSite(GETOBJPROP_FALLBACK);
    }

    /*
    public static CallSite bootstrapSetObjectProp(MethodHandles.Lookup lookup,
                                                  String name, MethodType type) {
        CachingCallSite callSite = new CachingCallSite(lookup, type);
        MethodHandle check = SETOBJPROP.bindTo(callSite);
        check = check.asType(type);

        callSite.setTarget(check);
        return callSite;
    }
    */

/*
    public static Object callProp0(CachingCallSite callSite, Object value,
                               String property, Context cx, Scriptable scope)
            throws Throwable {
        if (value.getClass() != NativeJavaObject.class) {
            callSite.setTarget(CALLPROP0_FALLBACK);
            return CALLPROP0_FALLBACK.invoke(value, property, cx, scope);
        }

        Object javaObject = ((NativeJavaObject)value).unwrap();
        Class<?> javaClass = javaObject.getClass();
        MethodHandle target, localTarget;
        target = callSite.lookup.unreflect(javaClass.getMethod(property));
        target = localTarget = target.asType(MethodType.genericMethodType(1));
        target = MethodHandles.filterArguments(target, 0, UNWRAP);
        target = MethodHandles.dropArguments(target, 1,
                String.class, Context.class, Scriptable.class);

        MethodHandle test = CHECK_CLASS.bindTo(javaClass);
        test = test.asType(MethodType.methodType(boolean.class, Object.class));

        MethodHandle guard = MethodHandles.guardWithTest(test, target, callSite.getTarget());
        callSite.setTarget(guard);

        return localTarget.invoke(javaObject);
    }

/*
    public static Object initGetObjectProp(CachingCallSite callSite, Object value,
                                           String property, Context cx, Scriptable scope)
        throws Throwable
    {
        if (value instanceof ScriptableObject) {
            final int mapping = ((ScriptableObject)value).getMapping(property);
            if (mapping >= 0) {
                return replaceGetFastObjectProp(callSite, value, property, cx, scope, mapping);
            }
        }

        // Otherwise, always fallback to ScriptRuntime.getObjectProp
        callSite.setTarget(GETOBJPROP_FALLBACK);
        return GETOBJPROP_FALLBACK.invoke(value, property, cx, scope);
    }
    */

/*
    public static Object getFastObjectProp(Object value, int index, String property, Context cx, Scriptable scope)
    {
        return ((ScriptableObject)value).getMappedSlot(index, scope);
    }

    public static boolean isSameObject(Object so, Object value)
    {
        return so == value;
    }

    private static Object replaceGetFastObjectProp(CachingCallSite callSite, Object value,
                                                   String property, Context cx, Scriptable scope,
                                                   int index)
            throws Throwable
    {
        // Make a MethodHandle that can go directly to the ScriptableObject
        // First arg is an int
        MethodHandle target = MethodHandles.insertArguments(GETFASTOBJPROP, 0, index);

        // Make a "guard" MethodHandle that will see if it's the same object
        MethodHandle test = MethodHandles.insertArguments(CHECK_SAME, 0, value);

        MethodHandle guard = MethodHandles.guardWithTest(test, target, GETOBJPROP_FALLBACK);
        callSite.setTarget(guard);
        return guard.invoke(value, property, cx, scope);
    }
*/
/*
        if (!(value instanceof ClassyScriptable)) {
            callSite.setTarget(GETOBJPROP_FALLBACK);
            return GETOBJPROP_FALLBACK.invoke(value, property, cx, scope);
        }

        ClassyScriptable classy = (ClassyScriptable) value;
        ClassyLayout layout = classy.getLayout();

        ClassyLayout.Mapping mapping = layout.findMapping(property);
        if (mapping == null) {
            callSite.setTarget(GETOBJPROP_FALLBACK);
            return GETOBJPROP_FALLBACK.invoke(value, property, cx, scope);
        }
        int offset = mapping.offset();

        MethodHandle target = MethodHandles.insertArguments(GETFASTOBJPROP, 1,
                Integer.valueOf(offset));
        target = MethodHandles.dropArguments(target, 1, String.class,
                Context.class, Scriptable.class);

        MethodHandle test = CHECK_LAYOUT.bindTo(layout);
        test = test.asType(MethodType.methodType(boolean.class, Object.class));

        MethodHandle guard = MethodHandles.guardWithTest(test, target, callSite.getTarget());
        callSite.setTarget(guard);
*/
        /* if (callSite.layout != layout) {
            ClassyLayout.Mapping mapping = layout.findMapping(property);
            if (mapping == null) {
                callSite.setTarget(GETOBJPROP_FALLBACK);
                return GETOBJPROP_FALLBACK.invoke(value, property, cx, scope);
            } else {
                callSite.layout = layout;
                callSite.offset = mapping.offset();
            }
        } */
/*
        return classy.getValueAtOffset(offset, classy);
    }

/*
    public static Object setObjectProp(CachingCallSite callSite, Object obj,
                               String property, Object value, Context cx)
            throws Throwable {
        if (!(obj instanceof ClassyScriptable)) {
            callSite.setTarget(SETOBJPROP_FALLBACK);
            return SETOBJPROP_FALLBACK.invoke(obj, property, value, cx);
        }

        ClassyScriptable classy = (ClassyScriptable) obj;
        ClassyLayout layout = classy.getLayout();
        
        Mapping mapping = layout.findMapping(property);
        int offset;
        
        if (mapping == null) {
            classy.put(property, classy, value);
            layout = classy.getLayout();
            mapping = layout.findMapping(property);
            offset = mapping.offset();
        } else {
            offset = mapping.offset();
            classy.putValueAtOffset(offset, classy, value);
        }
      
        MethodHandle target = MethodHandles.insertArguments(SETFASTOBJPROP, 1,
                Integer.valueOf(offset));
        target = MethodHandles.dropArguments(target, 1, String.class);
        target = MethodHandles.dropArguments(target, 3, Context.class);

        MethodHandle test = CHECK_LAYOUT.bindTo(layout);
        test = test.asType(MethodType.methodType(boolean.class, Object.class));

        MethodHandle guard = MethodHandles.guardWithTest(test, target, callSite.getTarget());
        callSite.setTarget(guard);
        return value;
    }
    */

    public static boolean checkObjectGeneration(int generation, ScriptableObject check, ScriptableObject so) {
        return (so == check) && so.checkGeneration(generation);
    }

    public static boolean checkSlotValue(int generation, ScriptableObject check,
        ScriptableObjectSlot slot, Object slotVal, ScriptableObject so) {
        return (so == check) &&
        so.checkGeneration(generation) &&
        slot.getValue(so) == slotVal;
    }

    public static Object getSlotValue(ScriptableObjectSlot slot,
        ScriptableObject so, String name, Context cx, Scriptable start)
    {
        return slot.getValue(so);
    }

    public static Object invokeSlot0(ScriptableObjectSlot slot,
            ScriptableObject so, String name, Context cx, Scriptable start)
    {
        return invokeSlot(so, name, cx, start, slot, ScriptRuntime.emptyArgs);
    }

    public static Object invokeSlot1(ScriptableObjectSlot slot,
        ScriptableObject so, String name, Object arg1, Context cx, Scriptable start)
    {
        return invokeSlot(so, name, cx, start, slot, new Object[]{arg1});
    }

    public static Object invokeSlot2(ScriptableObjectSlot slot,
        ScriptableObject so, String name, Object arg1, Object arg2,
        Context cx, Scriptable start)
    {
        return invokeSlot(so, name, cx, start, slot, new Object[]{arg1, arg2});
    }

    public static Object invokeSlotN(ScriptableObjectSlot slot,
        ScriptableObject so, String name, Object[] args, Context cx, Scriptable start)
    {
        return invokeSlot(so, name, cx, start, slot, args);
    }

    private static Object invokeSlot(ScriptableObject so, String name, Context cx, Scriptable start,
                                     ScriptableObjectSlot slot, Object[] args)
    {
        final Scriptable thisObj = ScriptRuntime.toObjectOrNull(cx, so, start);
        if (thisObj == null) {
            throw ScriptRuntime.undefCallError(so, name);
        }

        // Was this: ?!?
        // Object value = ScriptableObject.getProperty(thisObj, property);
        Object value = slot.getValue(thisObj);
        if (!(value instanceof Callable)) {
            Object noSuchMethod = ScriptableObject.getProperty(thisObj, "__noSuchMethod__");
            if (noSuchMethod instanceof Callable) {
                value = new ScriptRuntime.NoSuchMethodShim((Callable)noSuchMethod, name);
            }
        }

        if (!(value instanceof Callable)) {
            throw ScriptRuntime.notFunctionError(thisObj, value, name);
        }

        return ((Callable)value).call(cx, start, thisObj, args);
    }

    private static Object invokeFallback(Object so, String name,
                                         Object[] args, Context cx, Scriptable start)
    {
        Callable f = ScriptRuntime.getPropFunctionAndThis(so, name, cx, start);
        Scriptable thisObj = ScriptRuntime.lastStoredScriptable(cx);
        return f.call(cx, start, thisObj, args);
    }


    public static Object callProp1Fallback(Object so, String name,
                                           Object arg1, Context cx, Scriptable start)
    {
        return invokeFallback(so, name, new Object[]{arg1}, cx, start);
    }

    public static Object callProp2Fallback(Object so, String name,
                                           Object arg1, Object arg2, Context cx, Scriptable start)
    {
        return invokeFallback(so, name, new Object[]{arg1, arg2}, cx, start);
    }

    public static Object callPropNFallback(Object so, String name,
                                           Object[] args, Context cx, Scriptable start)
    {
        return invokeFallback(so, name, args, cx, start);
    }

    static final MethodHandle GETOBJPROP_FALLBACK;
    static final MethodHandle GETSCRIPTABLEOBJPROP;
    static final MethodHandle GETSLOTVALUE;
    static final MethodHandle INVOKESLOT0;
    static final MethodHandle INVOKESLOT1;
    static final MethodHandle INVOKESLOT2;
    static final MethodHandle INVOKESLOTN;
    static final MethodHandle CHECKOBJECTGENERATION;
    static final MethodHandle CHECKSLOTVALUE;
    static final MethodHandle CALLPROP0_FALLBACK;
    static final MethodHandle CALLPROP1_FALLBACK;
    static final MethodHandle CALLPROP2_FALLBACK;
    static final MethodHandle CALLPROPN_FALLBACK;
    static final MethodHandle CALLABLE_CALL;
    static final MethodHandle GETSOSLOTVALUE;

    //static final MethodHandle CHECK_SAME;
    //private static final MethodHandle CHECK_LAYOUT;
    //private static final MethodHandle INITCALL;
    //static final MethodHandle INITGETOBJPROP;

    //static final MethodHandle GETFASTOBJPROP;
    //private static final MethodHandle UNWRAP;
    //private static final MethodHandle SETOBJPROP_FALLBACK;
    //private static final MethodHandle SETOBJPROP;
    //private static final MethodHandle SETFASTOBJPROP;

    static {
        MethodHandles.Lookup lookup = MethodHandles.lookup();
        try {
            GETOBJPROP_FALLBACK = lookup.findStatic(ScriptRuntime.class, "getObjectProp",
                    MethodType.methodType(Object.class, Object.class,
                            String.class, Context.class, Scriptable.class));
            GETSCRIPTABLEOBJPROP = lookup.findStatic(ScriptRuntime.class, "getObjectProp",
                    MethodType.methodType(Object.class, Scriptable.class,
                            String.class, Context.class));
            GETSLOTVALUE = lookup.findStatic(InvokeDynamicSupport.class, "getSlotValue",
                    MethodType.methodType(Object.class, ScriptableObjectSlot.class,
                    ScriptableObject.class,
                    String.class, Context.class, Scriptable.class));
            INVOKESLOT0 = lookup.findStatic(InvokeDynamicSupport.class, "invokeSlot0",
                    MethodType.methodType(Object.class, ScriptableObjectSlot.class, ScriptableObject.class,
                            String.class, Context.class, Scriptable.class));
            INVOKESLOT1 = lookup.findStatic(InvokeDynamicSupport.class, "invokeSlot1",
                    MethodType.methodType(Object.class, ScriptableObjectSlot.class, ScriptableObject.class,
                            String.class, Object.class, Context.class, Scriptable.class));
            INVOKESLOT2 = lookup.findStatic(InvokeDynamicSupport.class, "invokeSlot2",
                    MethodType.methodType(Object.class, ScriptableObjectSlot.class, ScriptableObject.class,
                            String.class, Object.class, Object.class,
                            Context.class, Scriptable.class));
            INVOKESLOTN = lookup.findStatic(InvokeDynamicSupport.class, "invokeSlotN",
                    MethodType.methodType(Object.class, ScriptableObjectSlot.class, ScriptableObject.class,
                            String.class, Object[].class, Context.class, Scriptable.class));
            CHECKOBJECTGENERATION = lookup.findStatic(InvokeDynamicSupport.class, "checkObjectGeneration",
                    MethodType.methodType(Boolean.TYPE, Integer.TYPE, ScriptableObject.class,
                        ScriptableObject.class));
            CHECKSLOTVALUE = lookup.findStatic(InvokeDynamicSupport.class, "checkSlotValue",
                    MethodType.methodType(Boolean.TYPE, Integer.TYPE, ScriptableObject.class,
                            ScriptableObjectSlot.class, Object.class, ScriptableObject.class));
            CALLPROP0_FALLBACK = lookup.findStatic(OptRuntime.class, "callProp0",
                    MethodType.methodType(Object.class, Object.class,
                            String.class, Context.class, Scriptable.class));
            CALLPROP1_FALLBACK = lookup.findStatic(InvokeDynamicSupport.class, "callProp1Fallback",
                    MethodType.methodType(Object.class, Object.class,
                            String.class, Object.class, Context.class, Scriptable.class));
            CALLPROP2_FALLBACK = lookup.findStatic(InvokeDynamicSupport.class, "callProp2Fallback",
                    MethodType.methodType(Object.class, Object.class,
                            String.class, Object.class, Object.class, Context.class, Scriptable.class));
            CALLPROPN_FALLBACK = lookup.findStatic(InvokeDynamicSupport.class, "callPropNFallback",
                    MethodType.methodType(Object.class, Object.class,
                            String.class, Object[].class, Context.class, Scriptable.class));
            CALLABLE_CALL = lookup.findVirtual(Callable.class, "call",
                    MethodType.methodType(Object.class, Context.class, Scriptable.class,
                        Scriptable.class, Object[].class));
            GETSOSLOTVALUE = lookup.findGetter(ScriptableObject.Slot.class, "value", Object.class);

        /*
            INITGETOBJPROP = lookup.findStatic(InvokeDynamicSupport.class, "initGetObjectProp",
                    MethodType.methodType(Object.class, CachingCallSite.class,
                            Object.class, String.class, Context.class,
                            Scriptable.class));

            GETFASTOBJPROP = lookup.findStatic(InvokeDynamicSupport.class, "getFastObjectProp",
                    MethodType.methodType(Object.class, Object.class, Integer.TYPE,
                            String.class, Context.class,
                            Scriptable.class));
            CHECK_SAME = lookup.findStatic(InvokeDynamicSupport.class, "isSameObject",
                    MethodType.methodType(Boolean.TYPE, Object.class, Object.class));

            GETFASTOBJPROP = lookup.findStatic(InvokeDynamicSupport.class, "getFastObjectProp",
                    MethodType.methodType(Object.class, Integer.TYPE, Scriptable.class));
            CHECK_CLASS = lookup.findStatic(InvokeDynamicSupport.class, "checkClass",
                    MethodType.methodType(boolean.class, Class.class, Object.class));
            CHECK_LAYOUT = lookup.findStatic(InvokeDynamicSupport.class, "checkLayout",
                    MethodType.methodType(boolean.class, ClassyLayout.class, Object.class));

            UNWRAP = lookup.findStatic(InvokeDynamicSupport.class, "unwrapObject",
                    MethodType.methodType(Object.class, Object.class));
            SETOBJPROP_FALLBACK = lookup.findStatic(ScriptRuntime.class, "setObjectProp",
                    MethodType.methodType(Object.class, Object.class,
                            String.class, Object.class, Context.class));
            SETOBJPROP = lookup.findStatic(InvokeDynamicSupport.class, "setObjectProp",
                    MethodType.methodType(Object.class, CachingCallSite.class,
                            Object.class, String.class, Object.class, Context.class));
            SETFASTOBJPROP = lookup.findStatic(InvokeDynamicSupport.class, "setFastObjectProp",
                    MethodType.methodType(Object.class, Object.class, Integer.TYPE, Object.class));
                    */
        } catch (ReflectiveOperationException e) {
            throw new RuntimeException(e);
        }
    }
}
